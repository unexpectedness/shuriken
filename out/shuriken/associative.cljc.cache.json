["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$shuriken.associative","~:imports",null,"~:requires",["^ ","~$set","~$clojure.set","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$submap?",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","~:line",228,"~:column",7,"~:end-line",228,"~:end-column",14,"~:arglists",["~#list",["~$quote",["^G",[["~$map1","~$map2"]]]]],"~:doc","Determines whether `map1` is a subset, keys and values wise, of\n  `map2`."],"^5","~$shuriken.associative/submap?","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",14,"~:method-params",["^G",[["^I","^J"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^C",1,"~:variadic?",false,"^B",228,"~:ret-tag","~$boolean","^D",228,"~:max-fixed-arity",2,"~:fn-var",true,"^F",["^G",["^H",["^G",[["^I","^J"]]]]],"^K","Determines whether `map1` is a subset, keys and values wise, of\n  `map2`."],"~$index-by",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",132,"^C",7,"^D",132,"^E",15,"^F",["^G",["^H",["^G",[["~$f","~$coll"],["~$f","~$strategy","^V"]]]]],"^K","Like `group-by` except it applies a strategy to each grouped\n  collection.\n  A strategy is a function with signature `(key, entries) -> entry`\n  where `entry` is the one that will be indexed.\n  The default strategy asserts there is only one entry for the given\n  key and returns it.\n\n  ```clojure\n  (def ms [{:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 4}])\n\n  (index-by :a ms)\n  => {1 {:a 1 :b 2}\n      3 {:a 3 :b 4}\n      5 {:a 5 :b 4}}\n\n  (index-by :b ms)\n  => ; clojure.lang.ExceptionInfo (Duplicate entries for key 4)\n\n  (index-by :b (fn [key entries]\n                 (last entries))\n            ms)\n  => {2 {:a 1 :b 2}\n      4 {:a 5 :b 4}}\n  ```","~:top-fn",["^ ","^P",false,"~:fixed-arity",3,"^S",3,"^M",[["~$f","^V"],["~$f","^W","^V"]],"^F",["^G",[["~$f","^V"],["~$f","^W","^V"]]],"^O",["^G",[null,null]]]],"^5","~$shuriken.associative/index-by","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",15,"^X",["^ ","^P",false,"^Y",3,"^S",3,"^M",[["~$f","^V"],["~$f","^W","^V"]],"^F",["^G",[["~$f","^V"],["~$f","^W","^V"]]],"^O",["^G",[null,null]]],"^M",[["~$f","^V"],["~$f","^W","^V"]],"^N",null,"^Y",3,"^O",["^G",[null,null]],"^C",1,"^P",false,"~:methods",[["^ ","^Y",2,"^P",false,"~:tag","~$any"],["^ ","^Y",3,"^P",false,"^10",["^4",[null,"~$clj","^11"]]]],"^B",132,"^D",132,"^S",3,"^T",true,"^F",["^G",[["~$f","^V"],["~$f","^W","^V"]]],"^K","Like `group-by` except it applies a strategy to each grouped\n  collection.\n  A strategy is a function with signature `(key, entries) -> entry`\n  where `entry` is the one that will be indexed.\n  The default strategy asserts there is only one entry for the given\n  key and returns it.\n\n  ```clojure\n  (def ms [{:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 4}])\n\n  (index-by :a ms)\n  => {1 {:a 1 :b 2}\n      3 {:a 3 :b 4}\n      5 {:a 5 :b 4}}\n\n  (index-by :b ms)\n  => ; clojure.lang.ExceptionInfo (Duplicate entries for key 4)\n\n  (index-by :b (fn [key entries]\n                 (last entries))\n            ms)\n  => {2 {:a 1 :b 2}\n      4 {:a 5 :b 4}}\n  ```"],"~$map-intersection",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",222,"^C",7,"^D",222,"^E",23,"^F",["^G",["^H",["^G",[["~$m","~$&","~$ms"]]]]],"^K","Returns a submap of m including only entries whose key appear in all of\n  the remaining maps.","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^14"]]],"^F",["^G",[["~$m","~$&","^14"]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/map-intersection","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",23,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^14"]]],"^F",["^G",[["~$m","~$&","^14"]]],"^O",["^G",[null]]],"^M",[["^G",["~$m","^14"]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10","^12"]],"^B",222,"^Q","^11","^D",222,"^S",1,"^T",true,"^F",["^G",[["~$m","~$&","^14"]]],"^K","Returns a submap of m including only entries whose key appear in all of\n  the remaining maps."],"~$map-difference",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",216,"^C",7,"^D",216,"^E",21,"^F",["^G",["^H",["^G",[["~$m","~$&","^14"]]]]],"^K","Returns a submap of m excluding any entry whose key appear in any of\n  the remaining maps.","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^14"]]],"^F",["^G",[["~$m","~$&","^14"]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/map-difference","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",21,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^14"]]],"^F",["^G",[["~$m","~$&","^14"]]],"^O",["^G",[null]]],"^M",[["^G",["~$m","^14"]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10","^11"]],"^B",216,"^Q","^11","^D",216,"^S",1,"^T",true,"^F",["^G",[["~$m","~$&","^14"]]],"^K","Returns a submap of m excluding any entry whose key appear in any of\n  the remaining maps."],"~$filter-vals",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",35,"^C",7,"^D",35,"^E",18,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Filters `m` by applyng `f` to each value."],"^5","~$shuriken.associative/filter-vals","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",18,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",35,"^Q",["^4",[null,"~$seq","^12","~$cljs.core/IList","^11"]],"^D",35,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Filters `m` by applyng `f` to each value."],"~$deep-merge",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",107,"^C",7,"^D",107,"^E",17,"^F",["^G",["^H",["^G",[["~$m","~$&","~$more"]]]]],"^K","Deep merges two or more nested maps.\n\n  ```clojure\n  (deep-merge {:x {:a :a  :b :b  :c :c}}\n              {:x {:a :aa :b :bb}}\n              {:x {:a :aaa}})\n\n  => {:x {:a :aaa  :b :bb  :c :c}}\n  ```","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^1="]]],"^F",["^G",[["~$m","~$&","^1="]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/deep-merge","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",17,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^1="]]],"^F",["^G",[["~$m","~$&","^1="]]],"^O",["^G",[null]]],"^M",[["^G",["~$m","^1="]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10",["^4",[null,"^11"]]]],"^B",107,"^Q","^11","^D",107,"^S",1,"^T",true,"^F",["^G",[["~$m","~$&","^1="]]],"^K","Deep merges two or more nested maps.\n\n  ```clojure\n  (deep-merge {:x {:a :a  :b :b  :c :c}}\n              {:x {:a :aa :b :bb}}\n              {:x {:a :aaa}})\n\n  => {:x {:a :aaa  :b :bb  :c :c}}\n  ```"],"~$into-empty",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",6,"^C",8,"^D",6,"^E",18,"~:private",true,"^F",["^G",["^H",["^G",[["~$m","~$vs"]]]]]],"^1@",true,"^5","~$shuriken.associative/into-empty","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",18,"^M",["^G",[["~$m","^1A"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",6,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",6,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$m","^1A"]]]]]],"~$remove-vals",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",49,"^C",7,"^D",49,"^E",18,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Removes `m` by applyng `f` to each value."],"^5","~$shuriken.associative/remove-vals","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",18,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",49,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",49,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Removes `m` by applyng `f` to each value."],"~$flatten-keys",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",65,"^C",7,"^D",65,"^E",19,"^F",["^G",["^H",["^G",[["~$m"]]]]],"^K","Transforms a nested map into a map where keys are paths through\n  the original map and values are leafs these paths lead to.\n\n  ```clojure\n  (flatten-keys {:a {:b {:c :x\n                         :d :y}}})\n  => {[:a :b :c] :x\n      [:a :b :d] :y}\n  ```"],"^5","~$shuriken.associative/flatten-keys","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",19,"^M",["^G",[["~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",65,"^Q",["^4",[null,"^12","^11"]],"^D",65,"^S",1,"^T",true,"^F",["^G",["^H",["^G",[["~$m"]]]]],"^K","Transforms a nested map into a map where keys are paths through\n  the original map and values are leafs these paths lead to.\n\n  ```clojure\n  (flatten-keys {:a {:b {:c :x\n                         :d :y}}})\n  => {[:a :b :c] :x\n      [:a :b :d] :y}\n  ```"],"~$flatten-keys*",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",56,"^C",8,"^D",56,"^E",21,"^1@",true,"^F",["^G",["^H",["^G",[["~$acc","~$ks","~$m"]]]]]],"^1@",true,"^5","~$shuriken.associative/flatten-keys*","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",21,"^M",["^G",[["^1H","^1I","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",56,"^Q",["^4",[null,"^12","^11"]],"^D",56,"^S",3,"^T",true,"^F",["^G",["^H",["^G",[["^1H","^1I","~$m"]]]]]],"~$split-map",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",206,"^C",7,"^D",206,"^E",16,"^F",["^G",["^H",["^G",[["~$m","~$&","~$kss"]]]]],"^K","Returns a series of maps built by splitting `m` along each sequence\n  of keys in `kss`: the first map has `(first kss)` as keys, the second\n  one `(second kss)`, etc ... while the last map has the remaining keys\n  from `m`.","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^1L"]]],"^F",["^G",[["~$m","~$&","^1L"]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/split-map","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",16,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m","^1L"]]],"^F",["^G",[["~$m","~$&","^1L"]]],"^O",["^G",[null]]],"^M",[["^G",["~$m","^1L"]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10",["^4",["^12","~$cljs.core/IVector","^11","~$cljs.core/MetaFn","~$clj-nil"]]]],"^B",206,"^Q","^11","^D",206,"^S",1,"^T",true,"^F",["^G",[["~$m","~$&","^1L"]]],"^K","Returns a series of maps built by splitting `m` along each sequence\n  of keys in `kss`: the first map has `(first kss)` as keys, the second\n  one `(second kss)`, etc ... while the last map has the remaining keys\n  from `m`."],"~$merge-with-plan",["^ ","^5","~$shuriken.associative/merge-with-plan","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",196,"^C",1,"^D",196,"^E",21,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",196,"^C",6,"^D",196,"^E",21]],"~$map-keys",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",12,"^C",7,"^D",12,"^E",15,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Applies `f` to each key of `m`."],"^5","~$shuriken.associative/map-keys","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",15,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",12,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",12,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Applies `f` to each key of `m`."],"~$remove-keys",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",42,"^C",7,"^D",42,"^E",18,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Removes `m` by applyng `f` to each key."],"^5","~$shuriken.associative/remove-keys","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",18,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",42,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",42,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Removes `m` by applyng `f` to each key."],"~$deep-merge*",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",100,"^C",8,"^D",100,"^E",19,"^1@",true,"^F",["^G",["^H",["^G",[["~$m1f","~$&",["~$m2","~$&","^1="]]]]]],"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["^1X",["^1Y","~$&","^1="]]]],"^F",["^G",[["^1X","~$&",["^1Y","~$&","^1="]]]],"^O",["^G",[null]]]],"^1@",true,"^5","~$shuriken.associative/deep-merge*","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",19,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["^1X",["^1Y","~$&","^1="]]]],"^F",["^G",[["^1X","~$&",["^1Y","~$&","^1="]]]],"^O",["^G",[null]]],"^M",[["^G",["^1X",["^1Y","~$&","^1="]]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10",["^4",[null,"^11"]]]],"^B",100,"^Q","^11","^D",100,"^S",1,"^T",true,"^F",["^G",[["^1X","~$&",["^1Y","~$&","^1="]]]]],"~$filter-keys",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",28,"^C",7,"^D",28,"^E",18,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Filters `m` by applyng `f` to each key."],"^5","~$shuriken.associative/filter-keys","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",18,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",28,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",28,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Filters `m` by applyng `f` to each key."],"~$unindex",["^ ","^5","~$shuriken.associative/unindex","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",165,"^C",1,"^D",165,"^E",13,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",165,"^C",6,"^D",165,"^E",13],"^K","Alias of `vals`."],"~$continue|",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",198,"^C",7,"^D",198,"^E",16,"^F",["^G",["^H",["^G",[["~$fa","~$fb"]]]]],"^K","Takes two functions `fa` & `fb` and returns the partial application of `fb`\n  to `fa`.\n\n  See [[plan-merge]]."],"^5","~$shuriken.associative/continue|","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",16,"^M",["^G",[["^24","^25"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",198,"^Q","~$function","^D",198,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["^24","^25"]]]]],"^K","Takes two functions `fa` & `fb` and returns the partial application of `fb`\n  to `fa`.\n\n  See [[plan-merge]]."],"~$map-vals",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",20,"^C",7,"^D",20,"^E",15,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Applies `f` to each value of `m`."],"^5","~$shuriken.associative/map-vals","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",15,"^M",["^G",[["~$f","~$m"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",20,"^Q",["^4",[null,"^1:","^12","^1;","^11"]],"^D",20,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["~$f","~$m"]]]]],"^K","Applies `f` to each value of `m`."],"~$deflatten-keys",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",80,"^C",7,"^D",80,"^E",21,"^F",["^G",["^H",["^G",[["~$m","~$&",["^ ","~:keys",["~$with"],"~:or",["^ ","^2<",["^G",["~$fn*",["~$p1__10912#","~$p2__10911#"],["^G",["~$do","^2@"]]]]]]]]]]],"^K","Builds a nested map out of a map obtained from [[flatten-keys]].\n\n  ```clojure\n  (deflatten-keys {[:a :b :c] :x\n                   [:a :b :d] :y})\n  => {:a {:b {:c :x\n              :d :y}}}\n  ```","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^F",["^G",[["~$m","~$&",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/deflatten-keys","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",21,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["~$m",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^F",["^G",[["~$m","~$&",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^O",["^G",[null]]],"^M",[["^G",["~$m",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10",["^4",[null,"^11"]]]],"^B",80,"^Q","^11","^D",80,"^S",1,"^T",true,"^F",["^G",[["~$m","~$&",["^ ","^2;",["^2<"],"^2=",["^ ","^2<",["^G",["^2>",["^2?","^2@"],["^G",["^2A","^2@"]]]]]]]]],"^K","Builds a nested map out of a map obtained from [[flatten-keys]].\n\n  ```clojure\n  (deflatten-keys {[:a :b :c] :x\n                   [:a :b :d] :y})\n  => {:a {:b {:c :x\n              :d :y}}}\n  ```"],"~$getsoc",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",234,"^C",11,"^D",234,"^E",17,"~:macro",true,"^F",["^G",["^H",["^G",[["^V","~$k","~$expr"]]]]],"^K","Gets value at key `k` in hash `m` if present, otherwise eval\n  `expr` and stores its result in `m` under key `k`.\n  Returns a vector of the form [get-or-stored-value new-coll]."],"^5","~$shuriken.associative/getsoc","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",17,"^M",["^G",[["~$&form","~$&env","^V","~$k","^2E"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",234,"^2D",true,"^Q",["^4",["^1:","^1;"]],"^D",234,"^S",5,"^T",false,"^F",["^G",["^H",["^G",[["^V","~$k","^2E"]]]]],"^K","Gets value at key `k` in hash `m` if present, otherwise eval\n  `expr` and stores its result in `m` under key `k`.\n  Returns a vector of the form [get-or-stored-value new-coll]."],"~$raise-error-index-strategy",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",122,"^C",8,"^D",122,"^E",34,"^1@",true,"^F",["^G",["^H",["^G",[["~$key","~$entries"]]]]]],"^1@",true,"^5","~$shuriken.associative/raise-error-index-strategy","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",34,"^M",["^G",[["^2J","^2K"]]],"^N",null,"^O",["^G",[null,null]],"^C",1,"^P",false,"^B",122,"^Q",["^4",["^11","^1P"]],"^D",122,"^S",2,"^T",true,"^F",["^G",["^H",["^G",[["^2J","^2K"]]]]]],"~$plan-merge",["^ ","^?",null,"^@",["^ ","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^B",169,"^C",7,"^D",169,"^E",17,"^F",["^G",["^H",["^G",[["~$plan","~$&","~$maps"]]]]],"^K","Like `merge-with` except that the combination fn of a specific pair\n  of entries is determined by looking up their key in `plan`. If not\n  found, falls back to the function found under key `:else` or if not\n  provided to a function that returns the value in the right-most map,\n  thus providing the behavior of `merge`.\n  In addition to a map, `plan` can also be a function accepting a key\n  and returning a combination fn for the two values to merge.\n\n  You can use [[continue|]] to combine values of a key known to hold functions\n  in a cps-like style: namely, functions will be composed from right to left,\n  each one being passed as first argument the next function to call in the\n  chain.","^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["^2N","^2O"]]],"^F",["^G",[["^2N","~$&","^2O"]]],"^O",["^G",[null]]]],"^5","~$shuriken.associative/plan-merge","^A","/Users/clement/Documents/Code/Clojure/shuriken/src/shuriken/associative.cljc","^E",17,"^X",["^ ","^P",true,"^Y",1,"^S",1,"^M",[["^G",["^2N","^2O"]]],"^F",["^G",[["^2N","~$&","^2O"]]],"^O",["^G",[null]]],"^M",[["^G",["^2N","^2O"]]],"^N",null,"^Y",1,"^O",["^G",[null]],"^C",1,"^P",true,"^[",[["^ ","^Y",1,"^P",true,"^10",["^4",[null,"^11","^1P"]]]],"^B",169,"^Q","^11","^D",169,"^S",1,"^T",true,"^F",["^G",[["^2N","~$&","^2O"]]],"^K","Like `merge-with` except that the combination fn of a specific pair\n  of entries is determined by looking up their key in `plan`. If not\n  found, falls back to the function found under key `:else` or if not\n  provided to a function that returns the value in the right-most map,\n  thus providing the behavior of `merge`.\n  In addition to a map, `plan` can also be a function accepting a key\n  and returning a combination fn for the two values to merge.\n\n  You can use [[continue|]] to combine values of a key known to hold functions\n  in a cps-like style: namely, functions will be composed from right to left,\n  each one being passed as first argument the next function to call in the\n  chain."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:key","~:else","~:entries","^5","~$k__10968__auto__","~:type","~$cljs.core/contains?","~$if","~$cljs.core/let","~$coll__10967__auto__","~$cljs.core/get","~$expr__10969__auto__","~:index-by-duplicate-entries","~:with","~$cljs.core/assoc"]],"~:order",["^35","^5","^2Y","^2W","^2U","^34","^2V","^30","^31","^2X","^2[","^2Z","^32","^33","^36"]],"^K","### Operations on associative structures","~:as-aliases",["^ "]]